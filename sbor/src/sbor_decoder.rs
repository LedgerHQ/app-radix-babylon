// SBOR decoder

use crate::decoder_error::DecoderError;
use crate::sbor_notifications::SborEvent;
use crate::type_info::*;
use core::default::Default;
use core::option::Option::{None, Some};
use core::result::Result;
use core::result::Result::{Err, Ok};

pub const STACK_DEPTH: u8 = 48;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct State {
    items_to_read: u32,
    items_read: u32,
    len_acc: usize,
    phase_ptr: u8,
    element_type_id: u8,
    key_type_id: u8,
    value_type_id: u8,
    len_shift: u8,
    skip_start_end: bool,
    active_type: TypeInfo,
    phase: DecoderPhase,
    flip_flop: FlipFlopState,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum DecodingOutcome {
    Done(usize),
    NeedMoreData(usize),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
enum SubTypeKind {
    Element,
    Key,
    Value,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
enum FlipFlopState {
    Key,
    Value,
}

impl Default for State {
    fn default() -> Self {
        Self {
            phase: DecoderPhase::ReadingTypeId,
            phase_ptr: 0,
            active_type: NONE_TYPE_INFO,
            items_to_read: 0,
            items_read: 0,
            element_type_id: TYPE_NONE,
            key_type_id: TYPE_NONE,
            value_type_id: TYPE_NONE,
            len_shift: 0,
            len_acc: 0,
            skip_start_end: false,
            flip_flop: FlipFlopState::Key,
        }
    }
}

pub trait SborEventHandler {
    fn handle(&mut self, evt: SborEvent);
}

pub struct SborDecoder {
    stack: [State; STACK_DEPTH as usize],
    byte_count: usize,
    head: u8,
}

impl SborDecoder {
    pub fn new() -> Self {
        Self {
            stack: [State::default(); STACK_DEPTH as usize],
            byte_count: 0,
            head: 0,
        }
    }

    #[inline]
    fn head(&mut self) -> &mut State {
        &mut self.stack[self.head as usize]
    }

    #[inline]
    fn phase(&mut self) -> DecoderPhase {
        self.head().phase
    }

    pub fn push(&mut self) -> Result<(), DecoderError> {
        if self.head == STACK_DEPTH - 1 {
            let byte_count = self.byte_count;
            return Err(DecoderError::StackOverflow(byte_count));
        }
        self.head += 1;
        self.stack[self.head as usize] = State::default();

        Ok(())
    }

    pub fn pop(&mut self) -> Result<(), DecoderError> {
        if self.head == 0 {
            return Err(DecoderError::StackUnderflow(self.byte_count));
        }
        self.head -= 1;

        Ok(())
    }

    pub fn decode(
        &mut self,
        handler: &mut impl SborEventHandler,
        input: &[u8],
    ) -> Result<DecodingOutcome, DecoderError> {
        for byte in input {
            self.decode_byte(handler, *byte, true)?;
        }

        Ok(self.decoding_outcome())
    }

    pub fn decode_byte(
        &mut self,
        handler: &mut impl SborEventHandler,
        byte: u8,
        count_input: bool,
    ) -> Result<(), DecoderError> {
        if count_input {
            self.byte_count += 1;
        }

        match self.phase() {
            DecoderPhase::ReadingTypeId => self.read_type_id(handler, byte),
            DecoderPhase::ReadingLen => self.read_len(handler, byte),
            DecoderPhase::ReadingElementTypeId => {
                self.read_sub_type_id(handler, SubTypeKind::Element, byte)
            }
            DecoderPhase::ReadingKeyTypeId => {
                self.read_sub_type_id(handler, SubTypeKind::Key, byte)
            }
            DecoderPhase::ReadingValueTypeId => {
                self.read_sub_type_id(handler, SubTypeKind::Value, byte)
            }
            DecoderPhase::ReadingData => self.read_data(handler, byte),
            DecoderPhase::ReadingDiscriminator => {
                handler.handle(SborEvent::Discriminator(byte));
                self.advance_phase(handler)
            }
        }
    }

    fn decoding_outcome(&mut self) -> DecodingOutcome {
        if self.head == 0 && self.phase() == DecoderPhase::ReadingTypeId {
            DecodingOutcome::Done(self.byte_count)
        } else {
            DecodingOutcome::NeedMoreData(self.byte_count)
        }
    }

    fn advance_phase(&mut self, handler: &mut impl SborEventHandler) -> Result<(), DecoderError> {
        if self.head().is_last_phase() {
            {
                let level = self.head;
                let id = self.head().active_type.type_id;

                if !self.head().skip_start_end {
                    handler.handle(SborEvent::End {
                        type_id: id,
                        nesting_level: level,
                    });
                }
            }

            self.head().phase = DecoderPhase::ReadingTypeId;
            self.head().phase_ptr = 0;

            if self.head > 0 {
                self.pop()?;
            }
        } else {
            let mut head = self.head();
            head.phase_ptr += 1;
            head.phase = head.active_type.next_phases[head.phase_ptr as usize];
        }

        Ok(())
    }

    fn read_type_id(
        &mut self,
        handler: &mut impl SborEventHandler,
        byte: u8,
    ) -> Result<(), DecoderError> {
        let byte_count = self.byte_count;
        self.head().read_type_id(byte, byte_count)?;

        let size = self.size();

        if !self.head().skip_start_end {
            handler.handle(SborEvent::Start {
                type_id: byte,
                nesting_level: self.head,
                fixed_size: size,
            });
        }

        self.advance_phase(handler)
    }

    fn read_len(
        &mut self,
        handler: &mut impl SborEventHandler,
        byte: u8,
    ) -> Result<(), DecoderError> {
        let byte_count = self.byte_count;
        if self.head().read_len(byte, byte_count)? {
            handler.handle(SborEvent::Len(self.head().items_to_read));
            self.advance_phase(handler)?;

            // Automatically skip reading data if len is zero
            self.check_end_of_data_read(handler)
        } else {
            Ok(())
        }
    }

    fn read_sub_type_id(
        &mut self,
        handler: &mut impl SborEventHandler,
        sub_type: SubTypeKind,
        byte: u8,
    ) -> Result<(), DecoderError> {
        let byte_count = self.byte_count;
        self.head().read_sub_type_id(byte, sub_type, byte_count)?;
        self.advance_phase(handler)
    }

    fn read_data(
        &mut self,
        handler: &mut impl SborEventHandler,
        byte: u8,
    ) -> Result<(), DecoderError> {
        let byte_count = self.byte_count;

        match self.head().active_type.type_id {
            // fixed/variable len components with raw bytes payload
            // Unit..String | Custom types
            0x00..=0x0c | 0x80..=0xff => {
                handler.handle(SborEvent::Data(byte));
                self.read_single_data_byte(byte)
            }

            // variable length components with fields payload
            TYPE_TUPLE | TYPE_ENUM => {
                self.head().increment_items_read(byte_count)?; // Increment field count
                self.push()?; // Start new field
                self.decode_byte(handler, byte, false) // Read first byte (field type id)
            }

            // variable length component with flip/flop payload (key/value)
            TYPE_MAP => {
                let type_id = match self.head().flip_flop {
                    FlipFlopState::Key => {
                        self.head().flip_flop = FlipFlopState::Value;
                        self.head().key_type_id
                    }
                    FlipFlopState::Value => {
                        self.head().flip_flop = FlipFlopState::Key;
                        self.head().increment_items_read(byte_count)?; // Increment entry count
                        self.head().value_type_id
                    }
                };

                self.push()?; // Start key or value content read

                self.decode_byte(handler, type_id, false)?; // Set element type
                self.decode_byte(handler, byte, false) // Decode first byte of data
            }

            // variable length components with fixed payload type
            TYPE_ARRAY => {
                self.head().increment_items_read(byte_count)?; // Increment element count
                let type_id = self.head().element_type_id; // Prepare element type

                self.push()?; // Start new element

                match type_id {
                    // do not report start/end of each element for byte arrays
                    // instead they are reported like strings or enum name
                    TYPE_U8 | TYPE_I8 => {
                        self.head().skip_start_end = true;
                    }
                    _ => {}
                }

                self.decode_byte(handler, type_id, false)?; // Set element type
                self.decode_byte(handler, byte, false) // Decode first byte of data
            }

            _ => Err(DecoderError::InvalidState(byte_count)),
        }?;

        self.check_end_of_data_read(handler)
    }

    fn check_end_of_data_read(
        &mut self,
        handler: &mut impl SborEventHandler,
    ) -> Result<(), DecoderError> {
        while self.head().all_read() && self.head().is_read_data_phase() {
            self.advance_phase(handler)?
        }

        Ok(())
    }

    fn read_single_data_byte(&mut self, _byte: u8) -> Result<(), DecoderError> {
        let byte_count = self.byte_count;
        self.head().increment_items_read(byte_count)
    }

    fn size(&mut self) -> u8 {
        self.head().active_type.fixed_len
    }
}

impl State {
    #[inline]
    fn is_last_phase(&mut self) -> bool {
        self.phase_ptr == (self.active_type.next_phases.len() - 1) as u8
    }

    fn is_read_data_phase(&mut self) -> bool {
        self.phase == DecoderPhase::ReadingData
    }

    fn read_type_id(&mut self, byte: u8, byte_count: usize) -> Result<(), DecoderError> {
        match to_type_info(byte) {
            None => Err(DecoderError::InvalidInput(byte_count, byte)),
            Some(type_info) => {
                self.active_type = type_info;
                self.items_to_read = self.active_type.fixed_len as u32;
                self.items_read = 0;

                Ok(())
            }
        }
    }

    fn read_len(&mut self, byte: u8, byte_count: usize) -> Result<bool, DecoderError> {
        self.len_acc |= ((byte & 0x7F) as usize) << self.len_shift;

        if byte < 0x80 {
            self.items_read = 0;
            self.items_to_read = self.len_acc as u32;
            self.len_acc = 0;
            self.len_shift = 0;
            return Ok(true);
        }

        self.len_shift += 7;
        if self.len_shift >= 28 {
            return Err(DecoderError::InvalidLen(byte_count, byte));
        }

        Ok(false)
    }

    fn read_sub_type_id(
        &mut self,
        byte: u8,
        sub_type: SubTypeKind,
        byte_count: usize,
    ) -> Result<(), DecoderError> {
        match to_type_info(byte) {
            None => Err(DecoderError::InvalidInput(byte_count, byte)),
            Some(_) => {
                match sub_type {
                    SubTypeKind::Element => self.element_type_id = byte,
                    SubTypeKind::Key => self.key_type_id = byte,
                    SubTypeKind::Value => self.value_type_id = byte,
                }
                Ok(())
            }
        }
    }

    fn all_read(&mut self) -> bool {
        self.items_read == self.items_to_read
    }

    fn increment_items_read(&mut self, byte_count: usize) -> Result<(), DecoderError> {
        self.items_read += 1;

        if self.items_to_read < self.items_read {
            Err(DecoderError::InvalidState(byte_count))
        } else {
            Ok(())
        }
    }
}

#[cfg(test)]
mod tests {
    #[cfg(test)]
    use core::fmt::Display;
    use core::fmt::Formatter;
    use core::fmt::Result;

    use crate::sbor_decoder::{DecodingOutcome, SborDecoder, SborEventHandler};
    use crate::sbor_notifications::SborEvent;

    #[cfg(test)]
    impl Display for SborEvent {
        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
            match self {
                SborEvent::Start {
                    type_id,
                    nesting_level,
                    fixed_size,
                } => {
                    write!(
                        f,
                        "{}SborEvent::Start{{ type_id: {}, nesting_level: {}, fixed_size: {}}},",
                        " ".repeat(*nesting_level as usize),
                        *type_id,
                        *nesting_level,
                        *fixed_size
                    )
                }
                SborEvent::Len(len) => {
                    write!(f, "SborEvent::Len({}),", *len)
                }
                SborEvent::Discriminator(byte) => {
                    write!(f, "SborEvent::Name({:#02x}),", *byte)
                }
                SborEvent::Data(byte) => {
                    write!(f, "SborEvent::Data({:#02x}),", *byte)
                }
                SborEvent::End {
                    type_id,
                    nesting_level,
                } => {
                    write!(
                        f,
                        "{}SborEvent::End{{type_id: {}, nesting_level: {}}},",
                        " ".repeat(*nesting_level as usize),
                        *type_id,
                        *nesting_level
                    )
                }
            }
        }
    }

    #[derive(Debug)]
    struct EventCollector {
        collected: [SborEvent; 1600],
        count: usize,
    }

    impl SborEventHandler for EventCollector {
        fn handle(&mut self, evt: SborEvent) {
            assert_ne!(
                self.count,
                self.collected.len(),
                "evt = {}, count = {}",
                evt,
                self.count
            );
            self.collected[self.count] = evt;
            self.count += 1;
        }
    }

    impl EventCollector {
        pub fn new() -> Self {
            Self {
                collected: [SborEvent::Len(0); 1600],
                count: 0,
            }
        }

        pub fn compare(&self, vb: &[SborEvent]) -> bool {
            assert_eq!(
                self.count,
                vb.len(),
                "Different length: actual {}, expected {}",
                self.count,
                vb.len()
            );
            let mut cnt = 0;

            self.collected[0..self.count].iter().zip(vb).all(|(a, b)| {
                assert_eq!(*a, *b, "Elements are not equal at index {}", cnt);
                cnt += 1;
                true
            })
        }
    }

    fn check_decoding(input: &[u8], event_list: &[SborEvent]) {
        let mut decoder = SborDecoder::new();

        let mut handler = EventCollector::new();

        match decoder.decode(&mut handler, &input) {
            Ok(outcome) => {
                assert_eq!(outcome, DecodingOutcome::Done(input.len()))
            }
            Err(err) => {
                assert!(false, "Should not return an error {:?}", err)
            }
        }

        handler.compare(&event_list);
    }

    #[test]
    pub fn test_fixed_length_types_decoding() {
        let input: [u8; 76] = [
            33, 0, // unit
            1, 1, // bool
            2, 1, // i8
            3, 1, 0, // i16
            4, 1, 0, 0, 0, // i32
            5, 1, 0, 0, 0, 0, 0, 0, 0, // i64
            6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // i128
            7, 1, // u8
            8, 1, 0, // u16
            9, 1, 0, 0, 0, // u32
            10, 1, 0, 0, 0, 0, 0, 0, 0, // u64
            11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // u128
        ];

        check_decoding(
            &input,
            &[
                SborEvent::Start {
                    type_id: 33,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(0x0),
                SborEvent::End {
                    type_id: 33,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 1,
                    nesting_level: 0,
                    fixed_size: 1,
                },
                SborEvent::Data(0x1),
                SborEvent::End {
                    type_id: 1,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 2,
                    nesting_level: 0,
                    fixed_size: 1,
                },
                SborEvent::Data(0x1),
                SborEvent::End {
                    type_id: 2,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 3,
                    nesting_level: 0,
                    fixed_size: 2,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 3,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 4,
                    nesting_level: 0,
                    fixed_size: 4,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 4,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 5,
                    nesting_level: 0,
                    fixed_size: 8,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 5,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 6,
                    nesting_level: 0,
                    fixed_size: 16,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 6,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 7,
                    nesting_level: 0,
                    fixed_size: 1,
                },
                SborEvent::Data(0x1),
                SborEvent::End {
                    type_id: 7,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 8,
                    nesting_level: 0,
                    fixed_size: 2,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 8,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 0,
                    fixed_size: 4,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 10,
                    nesting_level: 0,
                    fixed_size: 8,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 10,
                    nesting_level: 0,
                },
                SborEvent::Start {
                    type_id: 11,
                    nesting_level: 0,
                    fixed_size: 16,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 11,
                    nesting_level: 0,
                },
            ],
        )
    }

    #[test]
    pub fn test_string_decoding() {
        let input: [u8; 7] = [
            12, 5, 104, 101, 108, 108, 111, // string
        ];

        check_decoding(
            &input,
            &[
                SborEvent::Start {
                    type_id: 12,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(5),
                SborEvent::Data(0x68),
                SborEvent::Data(0x65),
                SborEvent::Data(0x6c),
                SborEvent::Data(0x6c),
                SborEvent::Data(0x6f),
                SborEvent::End {
                    type_id: 12,
                    nesting_level: 0,
                },
            ],
        )
    }

    #[test]
    pub fn test_array_decoding() {
        let input: [u8; 35] = [
            32, 9, 3, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, // array
            32, 9, 3, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, // vec
            32, 7, 2, 1, 2, // set
        ];

        check_decoding(
            &input,
            &[
                // Array
                SborEvent::Start {
                    type_id: 32,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(3),
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x01),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x02),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x03),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 32,
                    nesting_level: 0,
                },
                // Vec
                SborEvent::Start {
                    type_id: 32,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(3),
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x01),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x02),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x03),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::Data(0x00),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 32,
                    nesting_level: 0,
                },
                // Set
                SborEvent::Start {
                    type_id: 32,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(2),
                SborEvent::Data(0x01),
                SborEvent::Data(0x02),
                SborEvent::End {
                    type_id: 32,
                    nesting_level: 0,
                },
            ],
        )
    }

    #[test]
    pub fn test_map_decoding() {
        let input: [u8; 8] = [
            35, 7, 7, 2, 1, 2, 3, 4, // map
        ];

        check_decoding(
            &input,
            &[
                SborEvent::Start {
                    type_id: 35,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(2),
                // Key 0
                SborEvent::Start {
                    type_id: 7,
                    nesting_level: 1,
                    fixed_size: 1,
                },
                SborEvent::Data(1),
                SborEvent::End {
                    type_id: 7,
                    nesting_level: 1,
                },
                // Value 0
                SborEvent::Start {
                    type_id: 7,
                    nesting_level: 1,
                    fixed_size: 1,
                },
                SborEvent::Data(2),
                SborEvent::End {
                    type_id: 7,
                    nesting_level: 1,
                },
                // Key 1
                SborEvent::Start {
                    type_id: 7,
                    nesting_level: 1,
                    fixed_size: 1,
                },
                SborEvent::Data(3),
                SborEvent::End {
                    type_id: 7,
                    nesting_level: 1,
                },
                // Value 1
                SborEvent::Start {
                    type_id: 7,
                    nesting_level: 1,
                    fixed_size: 1,
                },
                SborEvent::Data(4),
                SborEvent::End {
                    type_id: 7,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 35,
                    nesting_level: 0,
                },
            ],
        )
    }

    #[test]
    pub fn test_tuple_decoding() {
        let input: [u8; 12] = [
            33, 2, 9, 1, 0, 0, 0, 9, 2, 0, 0, 0, // tuple
        ];

        check_decoding(
            &input,
            &[
                SborEvent::Start {
                    type_id: 33,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Len(2),
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x2),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 33,
                    nesting_level: 0,
                },
            ],
        )
    }

    #[test]
    pub fn test_enum_decoding() {
        let input: [u8; 29] = [
            34, 0, 0, // None
            34, 1, 1, 9, 1, 0, 0, 0, // Some<T>
            34, 0, 1, 9, 1, 0, 0, 0, // Ok<T>
            34, 1, 1, 12, 5, 104, 101, 108, 108, 111, // Err<T>
        ];

        check_decoding(
            &input,
            &[
                // None
                SborEvent::Start {
                    type_id: 34,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Discriminator(0),
                SborEvent::Len(0),
                SborEvent::End {
                    type_id: 34,
                    nesting_level: 0,
                },
                // Some<T>
                SborEvent::Start {
                    type_id: 34,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Discriminator(1),
                SborEvent::Len(1),
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 34,
                    nesting_level: 0,
                },
                // Ok<T>
                SborEvent::Start {
                    type_id: 34,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Discriminator(0),
                SborEvent::Len(1),
                SborEvent::Start {
                    type_id: 9,
                    nesting_level: 1,
                    fixed_size: 4,
                },
                SborEvent::Data(0x1),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::Data(0x0),
                SborEvent::End {
                    type_id: 9,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 34,
                    nesting_level: 0,
                },
                // Err<T>
                SborEvent::Start {
                    type_id: 34,
                    nesting_level: 0,
                    fixed_size: 0,
                },
                SborEvent::Discriminator(1),
                SborEvent::Len(1),
                SborEvent::Start {
                    type_id: 12,
                    nesting_level: 1,
                    fixed_size: 0,
                },
                SborEvent::Len(5),
                SborEvent::Data(104),
                SborEvent::Data(101),
                SborEvent::Data(108),
                SborEvent::Data(108),
                SborEvent::Data(111),
                SborEvent::End {
                    type_id: 12,
                    nesting_level: 1,
                },
                SborEvent::End {
                    type_id: 34,
                    nesting_level: 0,
                },
            ],
        )
    }

    fn check_partial_decoding(input: &[u8]) {
        let mut decoder = SborDecoder::new();
        let mut handler = EventCollector::new();

        let mut start = 0;
        let mut end = 13;

        while start < input.len() {
            match decoder.decode(&mut handler, &input[start..end]) {
                Ok(outcome) => {
                    if end - start == 13 {
                        assert_eq!(outcome, DecodingOutcome::NeedMoreData(end));
                    } else {
                        assert_eq!(outcome, DecodingOutcome::Done(input.len()))
                    }
                }
                Err(_err) => {
                    assert!(false, "Should not return an error")
                }
            }

            start += 13;
            end += 13;

            if end > input.len() {
                end = input.len();
            }
        }
    }

    // ---------------------------------------------------- Full TX Intent
    #[test]
    pub fn test_access_rule1() {
        let input: [u8; 217] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x01, 0x1a, 0x04, 0x22, 0x00, 0x01, 0x81,
            0x02, 0x92, 0x56, 0x6c, 0x83, 0xde, 0x7f, 0xd6, 0xb0, 0x4f, 0xcc, 0x92, 0xb5, 0xe0,
            0x4b, 0x03, 0x22, 0x8c, 0xcf, 0xf0, 0x40, 0x78, 0x56, 0x73, 0x27, 0x8e, 0xf1, 0x09,
            0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x01, 0x0c, 0x04, 0x74, 0x65, 0x73, 0x74, 0x22,
            0x00, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0x46,
            0x2d, 0x52, 0xd7, 0x16, 0x75, 0x27, 0x23, 0x2d, 0x37, 0xac, 0xde, 0x9b, 0x86, 0xfa,
            0x02, 0x32, 0x88, 0x74, 0x18, 0xfe, 0x88, 0xe8, 0xf2, 0xa2, 0xf6, 0xff, 0xdc, 0xcc,
            0xc3, 0x9a, 0xa0, 0x17, 0xfa, 0x9d, 0xca, 0x6c, 0x60, 0xf3, 0xb5, 0x8d, 0xa4, 0x41,
            0x31, 0x47, 0x16, 0x71, 0xa6, 0xc3, 0xcd, 0xb4, 0x89, 0xfb, 0xbc, 0xc9, 0x17, 0x20,
            0x23, 0x1a, 0xb6, 0xd8, 0x9f, 0xe9, 0xbe,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_access_rule2() {
        let input: [u8; 300] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x23, 0x01, 0x22, 0x02, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01,
            0x22, 0x00, 0x01, 0x21, 0x02, 0x82, 0x00, 0x53, 0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38,
            0x35, 0x5e, 0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00, 0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64,
            0x8d, 0x5e, 0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0xa5, 0xa1,
            0x62, 0x47, 0xd1, 0x18, 0x13, 0xeb, 0xda, 0x57, 0x23, 0x89, 0x09, 0x82, 0x04, 0xff,
            0xe3, 0xcb, 0x94, 0x1a, 0xb3, 0xf6, 0x62, 0x75, 0xbe, 0x94, 0x8b, 0xca, 0x54, 0xb7,
            0x71, 0x4e, 0x2d, 0x71, 0x3c, 0xa3, 0xb8, 0x6b, 0x10, 0x20, 0xe9, 0x38, 0x85, 0x48,
            0xe8, 0xb2, 0xc2, 0x12, 0xfa, 0xd2, 0x13, 0x84, 0x0e, 0x74, 0xd7, 0x32, 0x35, 0xd6,
            0x1f, 0xde, 0xa5, 0xf2, 0xcd, 0x3d,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_fungible_resource_with_initial_supply() {
        let input: [u8; 446] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x03, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x1e, 0x04, 0x07, 0x12, 0x23, 0x0c, 0x0c, 0x03, 0x0b, 0x64, 0x65,
            0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76, 0x65,
            0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20,
            0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74, 0x20,
            0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x0a,
            0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x06, 0x73, 0x79, 0x6d,
            0x62, 0x6f, 0x6c, 0x04, 0x52, 0x53, 0x52, 0x43, 0x23, 0x22, 0x21, 0x02, 0x04, 0x00,
            0x02, 0x22, 0x00, 0x00, 0x22, 0x01, 0x00, 0x05, 0x00, 0x02, 0x22, 0x00, 0x00, 0x22,
            0x01, 0x00, 0x22, 0x01, 0x01, 0xb5, 0x00, 0x00, 0xb0, 0xd8, 0x6b, 0x90, 0x88, 0xa6,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03,
            0xa1, 0x66, 0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81,
            0x51, 0x8c, 0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x0d,
            0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x62, 0x61, 0x74, 0x63, 0x68, 0x20,
            0x07, 0x05, 0x5c, 0x21, 0x01, 0xa2, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22,
            0x00, 0x01, 0xb2, 0x01, 0xaf, 0xab, 0xa6, 0xf1, 0x88, 0xd8, 0xb9, 0x30, 0x1f, 0x22,
            0xa4, 0x26, 0x73, 0xe4, 0x07, 0x7a, 0xa6, 0xeb, 0x98, 0x9c, 0x59, 0xf7, 0xef, 0x4a,
            0xdf, 0x78, 0xa5, 0xd9, 0xd6, 0xa8, 0xa9, 0xc9, 0x49, 0xa0, 0x94, 0x4b, 0xe4, 0x40,
            0x18, 0x02, 0x70, 0x90, 0xc3, 0xf6, 0x28, 0x69, 0x90, 0x15, 0x4b, 0xed, 0x82, 0xe2,
            0xfc, 0x5c, 0x32, 0xc1, 0xe3, 0xf0, 0x76, 0x8b, 0x1c, 0xc4, 0x17, 0x88,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_fungible_resource_with_initial_supply_with_owner() {
        let input: [u8; 464] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x03, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x1f, 0x04, 0x07, 0x12, 0x23, 0x0c, 0x0c, 0x03, 0x0b, 0x64, 0x65,
            0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76, 0x65,
            0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20,
            0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74, 0x20,
            0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x0a,
            0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x06, 0x73, 0x79, 0x6d,
            0x62, 0x6f, 0x6c, 0x04, 0x52, 0x53, 0x52, 0x43, 0x21, 0x02, 0x82, 0x00, 0x10, 0xc0,
            0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb, 0xc1, 0x9e, 0xc8, 0x96,
            0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b, 0xb7, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x22, 0x01, 0x01, 0xb5, 0x00, 0x00, 0xb0, 0xd8,
            0x6b, 0x90, 0x88, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4,
            0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26,
            0x55, 0xb1, 0x0c, 0x0d, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x62, 0x61,
            0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c, 0x21, 0x01, 0xa2, 0x00, 0x20, 0x20, 0x00,
            0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0x28, 0x6a, 0x63, 0xf2, 0x9c, 0x21,
            0x1a, 0xb4, 0xee, 0x37, 0xd7, 0x05, 0x36, 0x2c, 0xb2, 0x05, 0x0e, 0x8e, 0xf3, 0xde,
            0xbf, 0xa2, 0xa1, 0x3e, 0xfa, 0xdd, 0x6d, 0xb5, 0xa2, 0x9c, 0x69, 0x0e, 0x71, 0x03,
            0xdd, 0x8f, 0x73, 0xfb, 0x4b, 0xe7, 0x2f, 0x8f, 0x18, 0x1b, 0x2d, 0x94, 0x98, 0xc1,
            0xcc, 0xbc, 0xdd, 0x34, 0x17, 0x75, 0x17, 0xfa, 0xa6, 0x04, 0x8c, 0x96, 0xcf, 0x7e,
            0x53, 0xf1,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_fungible_resource_with_no_initial_supply() {
        let input: [u8; 360] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x1e, 0x04, 0x07, 0x12, 0x23, 0x0c, 0x0c, 0x03, 0x0b, 0x64, 0x65,
            0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76, 0x65,
            0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20,
            0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74, 0x20,
            0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x0a,
            0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x06, 0x73, 0x79, 0x6d,
            0x62, 0x6f, 0x6c, 0x04, 0x52, 0x53, 0x52, 0x43, 0x23, 0x22, 0x21, 0x02, 0x04, 0x00,
            0x02, 0x22, 0x00, 0x00, 0x22, 0x01, 0x00, 0x05, 0x00, 0x02, 0x22, 0x00, 0x00, 0x22,
            0x01, 0x00, 0x22, 0x00, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01,
            0xb2, 0x00, 0x6b, 0x44, 0xd1, 0x1d, 0x86, 0xef, 0x26, 0x25, 0x3b, 0x7e, 0xff, 0x17,
            0xb1, 0x3f, 0x11, 0x2b, 0xaa, 0x61, 0x7e, 0xb8, 0x86, 0x72, 0x64, 0x44, 0xd6, 0xd4,
            0x81, 0x46, 0x6a, 0x03, 0x6d, 0xc5, 0x3f, 0xb7, 0x3f, 0x6e, 0x23, 0x3a, 0x20, 0x33,
            0xe5, 0xfe, 0xab, 0xba, 0x06, 0xd2, 0x31, 0x45, 0x47, 0x72, 0xec, 0xe6, 0x8d, 0xfd,
            0x30, 0x16, 0xc1, 0x11, 0x40, 0xf3, 0x61, 0x1b, 0xdf, 0x23,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_fungible_resource_with_no_initial_supply_with_owner() {
        let input: [u8; 378] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x1f, 0x04, 0x07, 0x12, 0x23, 0x0c, 0x0c, 0x03, 0x0b, 0x64, 0x65,
            0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76, 0x65,
            0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20,
            0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74, 0x20,
            0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x0a,
            0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x06, 0x73, 0x79, 0x6d,
            0x62, 0x6f, 0x6c, 0x04, 0x52, 0x53, 0x52, 0x43, 0x21, 0x02, 0x82, 0x00, 0x10, 0xc0,
            0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb, 0xc1, 0x9e, 0xc8, 0x96,
            0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b, 0xb7, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22,
            0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0x69, 0x1d, 0x9f, 0x54, 0xa2, 0x95, 0x03, 0x60,
            0x72, 0x62, 0x9e, 0x0c, 0xdf, 0xcb, 0x92, 0x35, 0x97, 0xbc, 0x54, 0x5b, 0x8a, 0x15,
            0x08, 0x61, 0x1b, 0x56, 0x6a, 0x13, 0x71, 0x8a, 0xb9, 0x2b, 0x66, 0x4c, 0x99, 0xe0,
            0x9c, 0x9b, 0x3a, 0xd8, 0x27, 0x67, 0x93, 0x63, 0x0e, 0x8d, 0x2e, 0xf0, 0x76, 0x3a,
            0x39, 0x3d, 0x11, 0x81, 0xcf, 0x3b, 0xff, 0x77, 0x85, 0x27, 0x95, 0xfc, 0xcb, 0xa6,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_non_fungible_resource_with_initial_supply() {
        let input: [u8; 493] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x03, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x20, 0x04, 0x22, 0x01, 0x00, 0x23, 0x0c, 0x0c, 0x02, 0x0b, 0x64,
            0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76,
            0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65,
            0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74,
            0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65,
            0x0a, 0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x23, 0x22, 0x21,
            0x02, 0x04, 0x00, 0x02, 0x22, 0x00, 0x00, 0x22, 0x01, 0x00, 0x05, 0x00, 0x02, 0x22,
            0x00, 0x00, 0x22, 0x01, 0x00, 0x22, 0x01, 0x01, 0x23, 0xb7, 0x21, 0x01, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x02, 0x20, 0x07, 0x31, 0x5c, 0x21, 0x02,
            0x0c, 0x0b, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0xb5,
            0x00, 0x00, 0xb0, 0xd8, 0x6b, 0x90, 0x88, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x20, 0x07, 0x16, 0x5c, 0x21, 0x02, 0x07, 0x0c, 0x0b, 0x13,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49,
            0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe,
            0x26, 0x55, 0xb1, 0x0c, 0x0d, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x62,
            0x61, 0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c, 0x21, 0x01, 0xa2, 0x00, 0x20, 0x20,
            0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0x7c, 0x5b, 0xee, 0xf1, 0x68,
            0x77, 0x73, 0x98, 0x54, 0xa7, 0x29, 0xd3, 0x1d, 0x76, 0x1c, 0x14, 0xbd, 0x29, 0xdd,
            0x80, 0xcb, 0x9c, 0x0f, 0xec, 0x0f, 0xec, 0x9a, 0x52, 0xcc, 0x36, 0x6c, 0x94, 0x30,
            0xa1, 0xc5, 0x89, 0xef, 0xd6, 0x38, 0xbf, 0x38, 0x37, 0x29, 0xb4, 0x74, 0x75, 0xf1,
            0x47, 0x9e, 0xb4, 0xce, 0x9c, 0xa4, 0x41, 0x20, 0x10, 0x60, 0x49, 0x03, 0x76, 0x63,
            0xb8, 0x25, 0xb6,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_non_fungible_resource_with_initial_supply_with_owner() {
        let input: [u8; 511] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x03, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x21, 0x04, 0x22, 0x01, 0x00, 0x23, 0x0c, 0x0c, 0x02, 0x0b, 0x64,
            0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76,
            0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65,
            0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74,
            0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65,
            0x0a, 0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x21, 0x02, 0x82,
            0x00, 0x10, 0xc0, 0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb, 0xc1,
            0x9e, 0xc8, 0x96, 0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b, 0xb7,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x22, 0x01, 0x01, 0x23, 0xb7,
            0x21, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x02, 0x20, 0x07,
            0x31, 0x5c, 0x21, 0x02, 0x0c, 0x0b, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
            0x72, 0x6c, 0x64, 0xb5, 0x00, 0x00, 0xb0, 0xd8, 0x6b, 0x90, 0x88, 0xa6, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x07, 0x16, 0x5c, 0x21, 0x02,
            0x07, 0x0c, 0x0b, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93,
            0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c,
            0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x0d, 0x64, 0x65, 0x70, 0x6f, 0x73,
            0x69, 0x74, 0x5f, 0x62, 0x61, 0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c, 0x21, 0x01,
            0xa2, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0x17,
            0x82, 0xd8, 0x5f, 0x55, 0xcb, 0x94, 0x68, 0x23, 0x1b, 0x53, 0x78, 0x54, 0x69, 0x94,
            0xb7, 0xbe, 0x5c, 0x74, 0xbd, 0xfb, 0x0f, 0xe4, 0x7f, 0x34, 0xcb, 0x1e, 0xb7, 0x2a,
            0x66, 0x50, 0x44, 0x27, 0xf7, 0x6f, 0x69, 0x01, 0x7b, 0x6c, 0x81, 0x2a, 0xf9, 0x5b,
            0x5e, 0xb4, 0x96, 0x18, 0xf2, 0xe7, 0x9f, 0xe8, 0xd9, 0xf8, 0x05, 0xbe, 0x75, 0x4e,
            0x4b, 0x18, 0xc2, 0xc5, 0xe1, 0x62, 0xce,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_non_fungible_resource_with_no_initial_supply() {
        let input: [u8; 349] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x20, 0x04, 0x22, 0x01, 0x00, 0x23, 0x0c, 0x0c, 0x02, 0x0b, 0x64,
            0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76,
            0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65,
            0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74,
            0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65,
            0x0a, 0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x23, 0x22, 0x21,
            0x02, 0x04, 0x00, 0x02, 0x22, 0x00, 0x00, 0x22, 0x01, 0x00, 0x05, 0x00, 0x02, 0x22,
            0x00, 0x00, 0x22, 0x01, 0x00, 0x22, 0x00, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00,
            0x22, 0x00, 0x01, 0xb2, 0x01, 0x47, 0x43, 0x04, 0x0f, 0xdf, 0x55, 0xa8, 0x79, 0x66,
            0x26, 0xd7, 0x53, 0xb5, 0x5f, 0x0d, 0x2a, 0x83, 0x11, 0xd1, 0xb7, 0xb1, 0x95, 0xe6,
            0x3d, 0x61, 0x5b, 0x8a, 0x63, 0x93, 0xea, 0x3e, 0x05, 0x3a, 0x07, 0x2d, 0x9e, 0x7b,
            0xb9, 0xc3, 0x07, 0x22, 0xad, 0xff, 0x72, 0x97, 0x9d, 0x8a, 0x64, 0x35, 0xef, 0x97,
            0x32, 0x0a, 0x0c, 0x26, 0xcc, 0x49, 0xa1, 0xf5, 0xb0, 0x3e, 0x17, 0xef, 0x52,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_create_non_fungible_resource_with_no_initial_supply_with_owner() {
        let input: [u8; 367] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x21, 0x04, 0x22, 0x01, 0x00, 0x23, 0x0c, 0x0c, 0x02, 0x0b, 0x64,
            0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x41, 0x20, 0x76,
            0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65,
            0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x74,
            0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65,
            0x0a, 0x4d, 0x79, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x21, 0x02, 0x82,
            0x00, 0x10, 0xc0, 0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb, 0xc1,
            0x9e, 0xc8, 0x96, 0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b, 0xb7,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0x20, 0x20,
            0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0xbd, 0x06, 0xfb, 0x6a, 0x7c,
            0x21, 0x43, 0x89, 0x96, 0x34, 0x66, 0xd8, 0x33, 0x17, 0x43, 0x52, 0xa0, 0x54, 0x2e,
            0x34, 0x43, 0x18, 0x8b, 0xb7, 0x9d, 0xc7, 0x7d, 0x5c, 0xd9, 0x8c, 0xfe, 0xa0, 0x7a,
            0x36, 0xe5, 0x3c, 0xe2, 0xe1, 0x3c, 0xd5, 0x12, 0x02, 0x4e, 0xa6, 0x94, 0xed, 0xe5,
            0x4c, 0xa7, 0xd6, 0x4e, 0x32, 0xf1, 0xf6, 0x4c, 0x6a, 0x85, 0x1d, 0x93, 0x29, 0xfc,
            0xe9, 0x1c, 0xab,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_invocation() {
        let input: [u8; 383] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x24, 0x04, 0x80, 0x01, 0x2b, 0x71,
            0x84, 0xfd, 0x2f, 0x42, 0x6f, 0xb4, 0x34, 0xc7, 0x44, 0xc3, 0x21, 0xcd, 0x91, 0xdf,
            0x83, 0x75, 0xb5, 0xe1, 0xf0, 0x1b, 0x74, 0x00, 0x9d, 0xff, 0x0c, 0x0d, 0x42, 0x6c,
            0x75, 0x65, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x0c, 0x01, 0x66,
            0x20, 0x07, 0x0b, 0x5c, 0x21, 0x01, 0x0c, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
            0x25, 0x03, 0x81, 0x02, 0x92, 0x56, 0x6c, 0x83, 0xde, 0x7f, 0xd6, 0xb0, 0x4f, 0xcc,
            0x92, 0xb5, 0xe0, 0x4b, 0x03, 0x22, 0x8c, 0xcf, 0xf0, 0x40, 0x78, 0x56, 0x73, 0x27,
            0x8e, 0xf1, 0x0c, 0x12, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65,
            0x64, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x20, 0x07, 0x65, 0x5c, 0x21, 0x02,
            0xb5, 0x00, 0x00, 0x64, 0xa7, 0xb3, 0xb6, 0xe0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x3e, 0xd4, 0x7e, 0xc9, 0xda, 0x71, 0xdc, 0xda, 0x2f, 0x4f, 0xb5, 0xe9, 0xf3,
            0x7f, 0xd2, 0x07, 0x9e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0xb1, 0xb5, 0x54,
            0x57, 0x4e, 0xe1, 0x5d, 0x1f, 0xe0, 0x2a, 0xf7, 0xda, 0x33, 0xb6, 0x91, 0x41, 0x75,
            0xc4, 0x69, 0x1b, 0x17, 0x79, 0xd5, 0xd8, 0x1d, 0x16, 0x72, 0x08, 0x94, 0x66, 0x34,
            0x97, 0x3a, 0x56, 0xab, 0xa1, 0x7c, 0x03, 0xc7, 0x8e, 0xbc, 0x19, 0xdb, 0x21, 0xbb,
            0x8d, 0x50, 0xd8, 0x92, 0x39, 0x70, 0xb8, 0x2b, 0x53, 0x99, 0xda, 0xe8, 0x36, 0x60,
            0x96, 0xd3, 0x59, 0x5d, 0xe8,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_metadata() {
        let input: [u8; 284] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x03, 0x15, 0x03, 0x22, 0x01, 0x01, 0x80,
            0x01, 0x2b, 0x71, 0x84, 0xfd, 0x2f, 0x42, 0x6f, 0xb4, 0x34, 0xc7, 0x44, 0xc3, 0x21,
            0xcd, 0x91, 0xdf, 0x83, 0x75, 0xb5, 0xe1, 0xf0, 0x1b, 0x74, 0x00, 0x9d, 0xff, 0x0c,
            0x01, 0x6b, 0x0c, 0x01, 0x76, 0x15, 0x03, 0x22, 0x00, 0x01, 0x81, 0x02, 0x15, 0x27,
            0x0b, 0xf1, 0xb9, 0xa7, 0x60, 0x13, 0x27, 0x5a, 0x65, 0x46, 0x44, 0x2a, 0x70, 0x7d,
            0x86, 0x14, 0xcd, 0xc4, 0x99, 0x59, 0xff, 0x51, 0x1e, 0x53, 0x0c, 0x01, 0x6b, 0x0c,
            0x01, 0x76, 0x15, 0x03, 0x22, 0x02, 0x01, 0x82, 0x00, 0x0f, 0x8e, 0x92, 0x0a, 0xa7,
            0x9f, 0x53, 0x34, 0x9d, 0x0a, 0x99, 0x74, 0x6e, 0x17, 0xb5, 0x92, 0x41, 0xbd, 0x51,
            0xe1, 0x9a, 0xbb, 0x50, 0xad, 0x6b, 0x6a, 0x0c, 0x01, 0x6b, 0x0c, 0x01, 0x76, 0x20,
            0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0x82, 0x5d, 0x02, 0x15,
            0x1d, 0x16, 0x66, 0x1c, 0xe4, 0x7c, 0x2c, 0x94, 0x20, 0xf1, 0x8c, 0x62, 0x42, 0x42,
            0xb7, 0x92, 0x75, 0x24, 0x9f, 0x1f, 0x97, 0x1c, 0x15, 0x52, 0x6f, 0x85, 0x39, 0x96,
            0x00, 0xb2, 0x57, 0x3b, 0x45, 0x93, 0x4e, 0x1e, 0xed, 0x08, 0x99, 0xdf, 0x04, 0xaa,
            0xf8, 0x31, 0xd9, 0xa4, 0xd7, 0x6f, 0x38, 0xa8, 0x4e, 0x22, 0x75, 0xc8, 0x54, 0x4f,
            0x5e, 0x87, 0xe9, 0x01,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_mint_fungible() {
        let input: [u8; 483] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x04, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93, 0x48, 0xe4,
            0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c, 0x70, 0xf9,
            0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x16, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f,
            0x70, 0x72, 0x6f, 0x6f, 0x66, 0x5f, 0x62, 0x79, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
            0x74, 0x20, 0x07, 0x40, 0x5c, 0x21, 0x02, 0xb5, 0x00, 0x00, 0x64, 0xa7, 0xb3, 0xb6,
            0xe0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00,
            0x5f, 0xea, 0x03, 0x73, 0xd4, 0x4e, 0x50, 0xd8, 0x11, 0x78, 0x42, 0x21, 0x43, 0x9d,
            0x6b, 0x69, 0x41, 0x91, 0xf5, 0xdc, 0x8d, 0xa2, 0xb0, 0xfa, 0x1d, 0x5c, 0x1b, 0x02,
            0x82, 0x00, 0x10, 0xc0, 0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb,
            0xc1, 0x9e, 0xc8, 0x96, 0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b,
            0xb5, 0x00, 0x00, 0xb0, 0xd8, 0x6b, 0x90, 0x88, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93,
            0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c,
            0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x0d, 0x64, 0x65, 0x70, 0x6f, 0x73,
            0x69, 0x74, 0x5f, 0x62, 0x61, 0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c, 0x21, 0x01,
            0xa2, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0x19,
            0x1c, 0xd2, 0xde, 0x5c, 0x93, 0x01, 0x37, 0xc5, 0x18, 0xaf, 0xb3, 0x8e, 0x0b, 0x59,
            0xf7, 0xcb, 0xe9, 0x1a, 0x3a, 0xaf, 0x8a, 0x04, 0x12, 0x47, 0xaa, 0x35, 0xc4, 0xd0,
            0xec, 0x6d, 0x14, 0x38, 0x52, 0x3f, 0x9f, 0x6e, 0xa8, 0x15, 0xc1, 0x1b, 0xec, 0x80,
            0xd9, 0xe1, 0xb5, 0x26, 0xa5, 0xb1, 0x8b, 0x8c, 0x3f, 0x20, 0xb2, 0x3b, 0xf5, 0xe4,
            0x3d, 0x26, 0xed, 0x32, 0x5b, 0x10, 0x70,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_mint_non_fungible() {
        let input: [u8; 541] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x04, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4, 0x14, 0x93, 0x48, 0xe4,
            0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a, 0x9f, 0x9c, 0x70, 0xf9,
            0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x16, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f,
            0x70, 0x72, 0x6f, 0x6f, 0x66, 0x5f, 0x62, 0x79, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
            0x74, 0x20, 0x07, 0x40, 0x5c, 0x21, 0x02, 0xb5, 0x00, 0x00, 0x64, 0xa7, 0xb3, 0xb6,
            0xe0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00,
            0x5f, 0xea, 0x03, 0x73, 0xd4, 0x4e, 0x50, 0xd8, 0x11, 0x78, 0x42, 0x21, 0x43, 0x9d,
            0x6b, 0x69, 0x41, 0x91, 0xf5, 0xdc, 0x8d, 0xa2, 0xb0, 0xfa, 0x1d, 0x5c, 0x1c, 0x02,
            0x82, 0x00, 0x10, 0xc0, 0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18, 0x65, 0x40, 0xbb,
            0xc1, 0x9e, 0xc8, 0x96, 0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01, 0xde, 0x0e, 0x2b,
            0x23, 0xb7, 0x21, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x02,
            0x20, 0x07, 0x31, 0x5c, 0x21, 0x02, 0x0c, 0x0b, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20,
            0x57, 0x6f, 0x72, 0x6c, 0x64, 0xb5, 0x00, 0x00, 0xb0, 0xd8, 0x6b, 0x90, 0x88, 0xa6,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x07, 0x16, 0x5c,
            0x21, 0x02, 0x07, 0x0c, 0x0b, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66, 0xd4,
            0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c, 0x0a,
            0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x0d, 0x64, 0x65, 0x70,
            0x6f, 0x73, 0x69, 0x74, 0x5f, 0x62, 0x61, 0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c,
            0x21, 0x01, 0xa2, 0x00, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2,
            0x00, 0xa7, 0x2b, 0x31, 0x47, 0xaf, 0xdb, 0xda, 0xe7, 0x6b, 0xe4, 0x30, 0x4b, 0x7a,
            0xb6, 0xe7, 0x09, 0xeb, 0x22, 0x7d, 0xe1, 0xce, 0x08, 0xad, 0xd0, 0x0d, 0x65, 0x2c,
            0x67, 0x1d, 0x8b, 0xde, 0xc6, 0x75, 0x30, 0x1a, 0x5b, 0x9b, 0xbe, 0xcc, 0xe9, 0xd6,
            0x9e, 0xd5, 0x5e, 0x71, 0x68, 0x2e, 0x00, 0x1c, 0x2d, 0xc1, 0xc8, 0xf3, 0xa5, 0x3c,
            0x1e, 0x69, 0x50, 0xfa, 0x99, 0x15, 0x29, 0x93, 0xec,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_publish_package() {
        let input: [u8; 1003] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x11, 0x05, 0xa3, 0x36, 0xda, 0xe5, 0x40, 0xb7, 0x88, 0x99, 0x56,
            0xf1, 0xf1, 0xd8, 0xd4, 0x6b, 0xa2, 0x3e, 0x5e, 0x44, 0xbf, 0x57, 0x23, 0xae, 0xf2,
            0xa8, 0xe6, 0xb6, 0x98, 0x68, 0x6c, 0x02, 0x58, 0x36, 0x18, 0xa3, 0x15, 0xe8, 0x69,
            0x9a, 0x6d, 0x63, 0xa9, 0x6f, 0x66, 0xf6, 0xfe, 0xeb, 0x60, 0x95, 0x49, 0xbe, 0x26,
            0x88, 0xb9, 0x6b, 0x02, 0x11, 0x9f, 0x26, 0x0a, 0xe6, 0xdf, 0xd0, 0x12, 0xd1, 0x6a,
            0x5d, 0x23, 0x0c, 0x21, 0x00, 0x23, 0x0c, 0x0c, 0x00, 0x21, 0x06, 0x23, 0x22, 0x22,
            0x04, 0x01, 0x01, 0x22, 0x02, 0x01, 0x22, 0x01, 0x00, 0x00, 0x01, 0x22, 0x02, 0x01,
            0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x21, 0x02, 0x82, 0x00, 0x53,
            0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e, 0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00,
            0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e, 0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x22, 0x02, 0x01, 0x22, 0x02,
            0x00, 0x00, 0x01, 0x22, 0x02, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00,
            0x01, 0x21, 0x02, 0x82, 0x00, 0x53, 0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e,
            0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00, 0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e,
            0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
            0x01, 0x22, 0x03, 0x01, 0x22, 0x00, 0x00, 0x00, 0x01, 0x22, 0x02, 0x01, 0x22, 0x00,
            0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x21, 0x02, 0x82, 0x00, 0x53, 0xf1, 0xc3,
            0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e, 0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00, 0xa7, 0x88,
            0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e, 0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x22, 0x03, 0x01, 0x22, 0x01, 0x00, 0x00,
            0x01, 0x22, 0x00, 0x00, 0x23, 0x0c, 0x22, 0x00, 0x22, 0x01, 0x00, 0x23, 0x22, 0x22,
            0x04, 0x01, 0x01, 0x22, 0x02, 0x01, 0x22, 0x01, 0x00, 0x02, 0x01, 0x22, 0x00, 0x01,
            0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x21, 0x02, 0x82, 0x00, 0x53, 0xf1, 0xc3, 0xe2,
            0x0c, 0xc2, 0x38, 0x35, 0x5e, 0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00, 0xa7, 0x88, 0x5c,
            0x2a, 0x82, 0x64, 0x8d, 0x5e, 0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x22, 0x02, 0x01, 0x22, 0x02, 0x00, 0x02, 0x01,
            0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x21, 0x02, 0x82, 0x00, 0x53,
            0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e, 0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00,
            0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e, 0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x22, 0x03, 0x01, 0x22, 0x00,
            0x00, 0x02, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x21, 0x02,
            0x82, 0x00, 0x53, 0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e, 0x23, 0xb0, 0x1d,
            0xec, 0xbb, 0x00, 0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e, 0x85, 0x9d, 0x4f,
            0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x22, 0x03,
            0x01, 0x22, 0x01, 0x00, 0x02, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00, 0x01, 0x22, 0x00,
            0x01, 0x21, 0x02, 0x82, 0x00, 0x53, 0xf1, 0xc3, 0xe2, 0x0c, 0xc2, 0x38, 0x35, 0x5e,
            0x23, 0xb0, 0x1d, 0xec, 0xbb, 0x00, 0xa7, 0x88, 0x5c, 0x2a, 0x82, 0x64, 0x8d, 0x5e,
            0x85, 0x9d, 0x4f, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23,
            0x0c, 0x22, 0x00, 0x22, 0x01, 0x00, 0x20, 0x20, 0x02, 0x07, 0x07, 0x32, 0x0c, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x07, 0xd2, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x30, 0x07,
            0xc0, 0x00, 0x00, 0x00, 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x04, 0x05,
            0x01, 0x70, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x00, 0x10, 0x06, 0x19, 0x03, 0x7f,
            0x01, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b, 0x7f, 0x00, 0x41, 0x80, 0x80, 0xc0, 0x00,
            0x0b, 0x7f, 0x00, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b, 0x07, 0x25, 0x03, 0x06, 0x6d,
            0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x0a, 0x5f, 0x5f, 0x64, 0x61, 0x74, 0x61,
            0x5f, 0x65, 0x6e, 0x64, 0x03, 0x01, 0x0b, 0x5f, 0x5f, 0x68, 0x65, 0x61, 0x70, 0x5f,
            0x62, 0x61, 0x73, 0x65, 0x03, 0x02, 0x00, 0x19, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x07,
            0x12, 0x01, 0x00, 0x0f, 0x5f, 0x5f, 0x73, 0x74, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x6f,
            0x69, 0x6e, 0x74, 0x65, 0x72, 0x00, 0x4d, 0x09, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63,
            0x65, 0x72, 0x73, 0x02, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x01,
            0x04, 0x52, 0x75, 0x73, 0x74, 0x00, 0x0c, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73,
            0x65, 0x64, 0x2d, 0x62, 0x79, 0x01, 0x05, 0x72, 0x75, 0x73, 0x74, 0x63, 0x1d, 0x31,
            0x2e, 0x35, 0x39, 0x2e, 0x30, 0x20, 0x28, 0x39, 0x64, 0x31, 0x62, 0x32, 0x31, 0x30,
            0x36, 0x65, 0x20, 0x32, 0x30, 0x32, 0x32, 0x2d, 0x30, 0x32, 0x2d, 0x32, 0x33, 0x29,
            0x32, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2,
            0x00, 0xbf, 0xb9, 0x96, 0x52, 0xd4, 0x19, 0xe3, 0x11, 0xea, 0xa0, 0x0a, 0xe0, 0xab,
            0x1a, 0xa5, 0xe4, 0x2b, 0x5d, 0x32, 0x31, 0x87, 0x7b, 0x25, 0x75, 0xea, 0x98, 0x09,
            0xbc, 0x15, 0xd5, 0xc5, 0x2e, 0x2d, 0x74, 0x0f, 0x76, 0xe9, 0x03, 0x9b, 0x42, 0x5e,
            0x3e, 0xfe, 0x1b, 0x68, 0x86, 0x96, 0x06, 0x98, 0xad, 0x8e, 0x1b, 0xaa, 0xca, 0xa1,
            0xce, 0xa7, 0x72, 0x49, 0x06, 0x33, 0x1a, 0xcc, 0xd2,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_publish_package_with_owner() {
        let input: [u8; 576] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x02, 0x25, 0x03, 0x81, 0x03, 0xa1, 0x66,
            0xd4, 0x14, 0x93, 0x48, 0xe4, 0xbb, 0x49, 0xf4, 0xbe, 0xed, 0xe0, 0x81, 0x51, 0x8c,
            0x0a, 0x9f, 0x9c, 0x70, 0xf9, 0x87, 0xbe, 0x26, 0x55, 0xb1, 0x0c, 0x08, 0x6c, 0x6f,
            0x63, 0x6b, 0x5f, 0x66, 0x65, 0x65, 0x20, 0x07, 0x24, 0x5c, 0x21, 0x01, 0xb5, 0x00,
            0x00, 0xe8, 0x89, 0x04, 0x23, 0xc7, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x12, 0x03, 0xa3, 0x36, 0xda, 0xe5, 0x40, 0xb7, 0x88, 0x99, 0x56,
            0xf1, 0xf1, 0xd8, 0xd4, 0x6b, 0xa2, 0x3e, 0x5e, 0x44, 0xbf, 0x57, 0x23, 0xae, 0xf2,
            0xa8, 0xe6, 0xb6, 0x98, 0x68, 0x6c, 0x02, 0x58, 0x36, 0x18, 0xa3, 0x15, 0xe8, 0x69,
            0x9a, 0x6d, 0x63, 0xa9, 0x6f, 0x66, 0xf6, 0xfe, 0xeb, 0x60, 0x95, 0x49, 0xbe, 0x26,
            0x88, 0xb9, 0x6b, 0x02, 0x11, 0x9f, 0x26, 0x0a, 0xe6, 0xdf, 0xd0, 0x12, 0xd1, 0x6a,
            0x5d, 0x21, 0x02, 0x82, 0x00, 0x10, 0xc0, 0x88, 0xe0, 0xf1, 0x03, 0x9e, 0x64, 0x18,
            0x65, 0x40, 0xbb, 0xc1, 0x9e, 0xc8, 0x96, 0x7b, 0x97, 0x71, 0x6e, 0x43, 0xb0, 0x01,
            0xde, 0x0e, 0x2b, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20,
            0x20, 0x02, 0x07, 0x07, 0x32, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x07, 0xd2, 0x01,
            0x10, 0x02, 0x00, 0x00, 0x00, 0x30, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x61, 0x73,
            0x6d, 0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x01, 0x70, 0x01, 0x01, 0x01, 0x05, 0x03,
            0x01, 0x00, 0x10, 0x06, 0x19, 0x03, 0x7f, 0x01, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b,
            0x7f, 0x00, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b, 0x7f, 0x00, 0x41, 0x80, 0x80, 0xc0,
            0x00, 0x0b, 0x07, 0x25, 0x03, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00,
            0x0a, 0x5f, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x65, 0x6e, 0x64, 0x03, 0x01, 0x0b,
            0x5f, 0x5f, 0x68, 0x65, 0x61, 0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x03, 0x02, 0x00,
            0x19, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x07, 0x12, 0x01, 0x00, 0x0f, 0x5f, 0x5f, 0x73,
            0x74, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x00, 0x4d,
            0x09, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x72, 0x73, 0x02, 0x08, 0x6c, 0x61,
            0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x01, 0x04, 0x52, 0x75, 0x73, 0x74, 0x00, 0x0c,
            0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x2d, 0x62, 0x79, 0x01, 0x05,
            0x72, 0x75, 0x73, 0x74, 0x63, 0x1d, 0x31, 0x2e, 0x35, 0x39, 0x2e, 0x30, 0x20, 0x28,
            0x39, 0x64, 0x31, 0x62, 0x32, 0x31, 0x30, 0x36, 0x65, 0x20, 0x32, 0x30, 0x32, 0x32,
            0x2d, 0x30, 0x32, 0x2d, 0x32, 0x33, 0x29, 0x32, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x00, 0x1d, 0x03, 0x6a, 0xbf, 0xad, 0xe1,
            0xef, 0x47, 0xe4, 0x30, 0x78, 0x70, 0x0b, 0x30, 0x74, 0xe2, 0xfb, 0x8d, 0x6a, 0x64,
            0xe9, 0x59, 0xd5, 0x3b, 0x2a, 0x63, 0xd8, 0x0f, 0x10, 0x35, 0x12, 0xc8, 0x50, 0x3a,
            0x65, 0x58, 0x70, 0xd4, 0xbc, 0x98, 0xd8, 0x2a, 0xcd, 0x98, 0x3e, 0xf6, 0xd4, 0x78,
            0xbb, 0x08, 0x62, 0xc3, 0x4e, 0x06, 0x46, 0x70, 0x3b, 0x85, 0xab, 0x49, 0xab, 0xe1,
            0x33, 0xf9,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_resource_recall() {
        let input: [u8; 241] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x01, 0x14, 0x02, 0x20, 0x07, 0x24, 0x49,
            0xcd, 0x92, 0x35, 0xba, 0x62, 0xb2, 0xc2, 0x17, 0xe3, 0x2e, 0x5b, 0x47, 0x54, 0xc0,
            0x82, 0x19, 0xef, 0x16, 0x38, 0x97, 0x61, 0x35, 0x6e, 0xac, 0xcb, 0xf6, 0xf6, 0xbd,
            0xbf, 0xa4, 0x4d, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x00, 0x78, 0x62, 0xa4, 0x41,
            0xa7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20,
            0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0x94, 0x14, 0x11, 0xae, 0x72,
            0x19, 0x9e, 0x9f, 0x76, 0xd9, 0xbe, 0x40, 0x5e, 0x92, 0x6e, 0x97, 0x66, 0x04, 0xae,
            0xcb, 0x86, 0xa3, 0xd1, 0xe2, 0x28, 0x3c, 0x25, 0xea, 0x0d, 0x05, 0xec, 0x7a, 0x4b,
            0x28, 0x40, 0x0e, 0x99, 0x9b, 0x97, 0x6a, 0x87, 0x80, 0x59, 0x71, 0x74, 0x15, 0x85,
            0x00, 0x1f, 0xed, 0x9a, 0xc0, 0x4d, 0xc6, 0xae, 0x54, 0xb8, 0x04, 0x54, 0x21, 0xd3,
            0xa7, 0xf4, 0xb2,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_resource_worktop() {
        let input: [u8; 786] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x11, 0x25, 0x03, 0x81, 0x03, 0xd4, 0x3f,
            0x47, 0x9e, 0x9b, 0x2b, 0xeb, 0x9d, 0xf9, 0x8b, 0xc3, 0x88, 0x83, 0x44, 0xfc, 0x25,
            0xed, 0xa1, 0x81, 0xe8, 0xf7, 0x10, 0xce, 0x1b, 0xf1, 0xde, 0x0c, 0x12, 0x77, 0x69,
            0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x5f, 0x62, 0x79, 0x5f, 0x61, 0x6d, 0x6f, 0x75,
            0x6e, 0x74, 0x20, 0x07, 0x40, 0x5c, 0x21, 0x02, 0xb5, 0x00, 0x00, 0xf4, 0x44, 0x82,
            0x91, 0x63, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01,
            0x02, 0xb5, 0x00, 0x00, 0xc8, 0x4e, 0x67, 0x6d, 0xc1, 0x1b, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x25, 0x03, 0x81, 0x02, 0x92, 0x56, 0x6c, 0x83,
            0xde, 0x7f, 0xd6, 0xb0, 0x4f, 0xcc, 0x92, 0xb5, 0xe0, 0x4b, 0x03, 0x22, 0x8c, 0xcf,
            0xf0, 0x40, 0x78, 0x56, 0x73, 0x27, 0x8e, 0xf1, 0x0c, 0x0b, 0x62, 0x75, 0x79, 0x5f,
            0x67, 0x75, 0x6d, 0x62, 0x61, 0x6c, 0x6c, 0x20, 0x07, 0x08, 0x5c, 0x21, 0x01, 0xa0,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0xb5, 0x00, 0x00, 0x2c, 0xf6, 0x1a, 0x24, 0xa2,
            0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x01, 0x82,
            0x00, 0xae, 0xdb, 0x79, 0x60, 0xd1, 0xf8, 0x7d, 0xc2, 0x51, 0x38, 0xf4, 0xcd, 0x10,
            0x1d, 0xa6, 0xc9, 0x8d, 0x57, 0x32, 0x34, 0x78, 0xd5, 0x3c, 0x5f, 0xb9, 0x51, 0x00,
            0x01, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x04, 0x0d, 0x01, 0xa0, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x01, 0xa1, 0x02, 0x00, 0x00,
            0x00, 0x0f, 0x01, 0xa1, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xa1, 0x03, 0x00, 0x00,
            0x00, 0x25, 0x03, 0x81, 0x03, 0xd4, 0x3f, 0x47, 0x9e, 0x9b, 0x2b, 0xeb, 0x9d, 0xf9,
            0x8b, 0xc3, 0x88, 0x83, 0x44, 0xfc, 0x25, 0xed, 0xa1, 0x81, 0xe8, 0xf7, 0x10, 0xce,
            0x1b, 0xf1, 0xde, 0x0c, 0x16, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x72,
            0x6f, 0x6f, 0x66, 0x5f, 0x62, 0x79, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20,
            0x07, 0x40, 0x5c, 0x21, 0x02, 0xb5, 0x00, 0x00, 0xf4, 0x44, 0x82, 0x91, 0x63, 0x45,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x00, 0x0f, 0x01,
            0xa1, 0x04, 0x00, 0x00, 0x00, 0x03, 0x01, 0xa0, 0x01, 0x00, 0x00, 0x00, 0x02, 0x02,
            0x20, 0xb7, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x82, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x00,
            0x25, 0x03, 0x81, 0x03, 0xd4, 0x3f, 0x47, 0x9e, 0x9b, 0x2b, 0xeb, 0x9d, 0xf9, 0x8b,
            0xc3, 0x88, 0x83, 0x44, 0xfc, 0x25, 0xed, 0xa1, 0x81, 0xe8, 0xf7, 0x10, 0xce, 0x1b,
            0xf1, 0xde, 0x0c, 0x0d, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x62, 0x61,
            0x74, 0x63, 0x68, 0x20, 0x07, 0x05, 0x5c, 0x21, 0x01, 0xa2, 0x00, 0x20, 0x20, 0x00,
            0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0xfd, 0x80, 0xc6, 0x6f, 0x68, 0xe0,
            0x36, 0xc5, 0x08, 0x2d, 0x74, 0x0e, 0x37, 0x05, 0xdb, 0x20, 0x27, 0x70, 0x40, 0x8c,
            0xd6, 0x51, 0x74, 0x75, 0x1d, 0x85, 0x06, 0x9e, 0xc2, 0x94, 0xad, 0xcf, 0x58, 0x59,
            0x30, 0x08, 0x8b, 0xfc, 0xa9, 0x7b, 0xb0, 0x12, 0x07, 0xd8, 0x71, 0xe5, 0xfb, 0xdd,
            0x3b, 0xc7, 0xa4, 0xc2, 0x4c, 0x02, 0x7c, 0x68, 0xda, 0x33, 0x2d, 0xac, 0x8f, 0xb6,
            0x39, 0x97,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_royalty() {
        let input: [u8; 344] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x04, 0x16, 0x02, 0x80, 0x01, 0x2b, 0x71,
            0x84, 0xfd, 0x2f, 0x42, 0x6f, 0xb4, 0x34, 0xc7, 0x44, 0xc3, 0x21, 0xcd, 0x91, 0xdf,
            0x83, 0x75, 0xb5, 0xe1, 0xf0, 0x1b, 0x74, 0x00, 0x9d, 0xff, 0x23, 0x0c, 0x21, 0x01,
            0x09, 0x42, 0x6c, 0x75, 0x65, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x02, 0x23, 0x0c, 0x09,
            0x01, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00,
            0x00, 0x00, 0x00, 0x17, 0x02, 0x81, 0x02, 0x15, 0x27, 0x0b, 0xf1, 0xb9, 0xa7, 0x60,
            0x13, 0x27, 0x5a, 0x65, 0x46, 0x44, 0x2a, 0x70, 0x7d, 0x86, 0x14, 0xcd, 0xc4, 0x99,
            0x59, 0xff, 0x51, 0x1e, 0x53, 0x21, 0x02, 0x23, 0x0c, 0x09, 0x01, 0x06, 0x6d, 0x65,
            0x74, 0x68, 0x6f, 0x64, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x18,
            0x01, 0x80, 0x01, 0x2b, 0x71, 0x84, 0xfd, 0x2f, 0x42, 0x6f, 0xb4, 0x34, 0xc7, 0x44,
            0xc3, 0x21, 0xcd, 0x91, 0xdf, 0x83, 0x75, 0xb5, 0xe1, 0xf0, 0x1b, 0x74, 0x00, 0x9d,
            0xff, 0x19, 0x01, 0x81, 0x02, 0x15, 0x27, 0x0b, 0xf1, 0xb9, 0xa7, 0x60, 0x13, 0x27,
            0x5a, 0x65, 0x46, 0x44, 0x2a, 0x70, 0x7d, 0x86, 0x14, 0xcd, 0xc4, 0x99, 0x59, 0xff,
            0x51, 0x1e, 0x53, 0x20, 0x20, 0x00, 0x20, 0x22, 0x00, 0x22, 0x00, 0x01, 0xb2, 0x01,
            0x74, 0xe2, 0xa0, 0x0e, 0xbd, 0x46, 0x7a, 0x9a, 0x12, 0xfd, 0xd6, 0x67, 0x0b, 0x50,
            0x9a, 0x58, 0xd7, 0xb9, 0x87, 0x85, 0x83, 0x8d, 0x90, 0x18, 0xd9, 0x89, 0xea, 0x14,
            0x8c, 0x3a, 0x1a, 0xf5, 0x62, 0x61, 0x4c, 0x35, 0x52, 0xb9, 0x9e, 0xef, 0xa6, 0xee,
            0xd7, 0x59, 0xd3, 0x94, 0x0e, 0x6a, 0xfa, 0x14, 0x7c, 0x92, 0xf8, 0x26, 0x39, 0xb1,
            0x25, 0x67, 0x4c, 0x99, 0xae, 0x8c, 0x95, 0x4d,
        ];
        check_partial_decoding(&input);
    }

    #[test]
    pub fn test_values() {
        let input: [u8; 1736] = [
            0x5c, 0x21, 0x02, 0x21, 0x02, 0x21, 0x02, 0x21, 0x09, 0x07, 0x01, 0x07, 0x01, 0x0a,
            0xe1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00,
            0x01, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
            0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59,
            0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x01, 0x01, 0x09, 0x40, 0x42, 0x0f, 0x00,
            0x08, 0x05, 0x00, 0x21, 0x02, 0x20, 0x22, 0x05, 0x00, 0x01, 0x82, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0a, 0x01, 0x82, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x25, 0x03,
            0x81, 0x02, 0x92, 0x56, 0x6c, 0x83, 0xde, 0x7f, 0xd6, 0xb0, 0x4f, 0xcc, 0x92, 0xb5,
            0xe0, 0x4b, 0x03, 0x22, 0x8c, 0xcf, 0xf0, 0x40, 0x78, 0x56, 0x73, 0x27, 0x8e, 0xf1,
            0x0c, 0x15, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x62, 0x61,
            0x73, 0x69, 0x63, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x07, 0x05, 0x5c, 0x21,
            0x01, 0x21, 0x00, 0x25, 0x03, 0x81, 0x02, 0x92, 0x56, 0x6c, 0x83, 0xde, 0x7f, 0xd6,
            0xb0, 0x4f, 0xcc, 0x92, 0xb5, 0xe0, 0x4b, 0x03, 0x22, 0x8c, 0xcf, 0xf0, 0x40, 0x78,
            0x56, 0x73, 0x27, 0x8e, 0xf1, 0x0c, 0x0c, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x61, 0x6c,
            0x69, 0x61, 0x73, 0x65, 0x73, 0x20, 0x07, 0xa7, 0x04, 0x5c, 0x21, 0x18, 0x22, 0x00,
            0x00, 0x22, 0x00, 0x00, 0x22, 0x01, 0x01, 0x0c, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
            0x22, 0x01, 0x01, 0x0c, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x22, 0x00, 0x01, 0x0c,
            0x04, 0x74, 0x65, 0x73, 0x74, 0x22, 0x00, 0x01, 0x0c, 0x04, 0x74, 0x65, 0x73, 0x74,
            0x22, 0x01, 0x01, 0x0c, 0x07, 0x74, 0x65, 0x73, 0x74, 0x31, 0x32, 0x33, 0x22, 0x01,
            0x01, 0x0c, 0x07, 0x74, 0x65, 0x73, 0x74, 0x31, 0x32, 0x33, 0x22, 0x00, 0x00, 0x22,
            0x01, 0x01, 0x0c, 0x01, 0x61, 0x22, 0x00, 0x01, 0x0c, 0x01, 0x62, 0x22, 0x01, 0x01,
            0x0c, 0x01, 0x63, 0x20, 0x07, 0x04, 0xde, 0xad, 0xbe, 0xef, 0x20, 0x07, 0x03, 0x05,
            0x0a, 0xff, 0x21, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x04, 0xb7, 0x00, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x21, 0x02,
            0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
            0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x21, 0x02, 0x82, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xb7, 0x01,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc8, 0x21, 0x02, 0x82, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xb7, 0x02, 0x21, 0x03,
            0x1b, 0x84, 0xc5, 0x56, 0x7b, 0x12, 0x64, 0x40, 0x99, 0x5d, 0x3e, 0xd5, 0xaa, 0xba,
            0x05, 0x65, 0xd7, 0x1e, 0x18, 0x34, 0x60, 0x48, 0x19, 0xff, 0x9c, 0x17, 0xf5, 0xe9,
            0xd5, 0xdd, 0x07, 0x8f, 0x21, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x49, 0x96,
            0x02, 0xd2, 0x21, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x04, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x20, 0x20, 0x02, 0x07, 0x02, 0xde, 0xad, 0x07, 0x03, 0x05, 0x0a, 0xff, 0x20, 0x20,
            0x02, 0x07, 0x02, 0xde, 0xad, 0x07, 0x03, 0x05, 0x0a, 0xff, 0x20, 0x21, 0x02, 0x02,
            0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
            0xb7, 0x00, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xb7, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x21, 0x02, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xb7, 0x00, 0x05, 0x76, 0x61,
            0x6c, 0x75, 0x65, 0x02, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x04, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x25, 0x03, 0x81, 0x02, 0x92, 0x56, 0x6c, 0x83, 0xde, 0x7f, 0xd6, 0xb0, 0x4f, 0xcc,
            0x92, 0xb5, 0xe0, 0x4b, 0x03, 0x22, 0x8c, 0xcf, 0xf0, 0x40, 0x78, 0x56, 0x73, 0x27,
            0x8e, 0xf1, 0x0c, 0x1d, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x61, 0x6c, 0x6c, 0x5f, 0x73,
            0x63, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x5f, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f,
            0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x07, 0xb2, 0x04, 0x5c, 0x21, 0x13, 0x80, 0x01,
            0x00, 0x2c, 0x64, 0xcc, 0x99, 0x11, 0xa7, 0x8b, 0xdf, 0x9f, 0xdd, 0xde, 0x5f, 0x5a,
            0x9d, 0xc4, 0x88, 0xec, 0xeb, 0xc5, 0xd5, 0x23, 0xbb, 0x0f, 0xcf, 0x9e, 0x81, 0x03,
            0xf8, 0x54, 0x1b, 0x2e, 0x91, 0xa4, 0x79, 0xdc, 0xdc, 0xec, 0x31, 0x75, 0xdd, 0x5b,
            0x46, 0x67, 0x8d, 0xf5, 0x57, 0x0d, 0x90, 0xe1, 0x45, 0xf0, 0x2b, 0xbf, 0x82, 0x00,
            0x0f, 0x8e, 0x92, 0x0a, 0xa7, 0x9f, 0x53, 0x34, 0x9d, 0x0a, 0x99, 0x74, 0x6e, 0x17,
            0xb5, 0x92, 0x41, 0xbd, 0x51, 0xe1, 0x9a, 0xbb, 0x50, 0xad, 0x6b, 0x6a, 0x81, 0x04,
            0xf2, 0x70, 0x72, 0xb0, 0xc9, 0x18, 0x24, 0xa1, 0xa5, 0xa8, 0x62, 0x23, 0x8e, 0x58,
            0x6f, 0xe2, 0xc7, 0xcd, 0x37, 0x61, 0xeb, 0x2e, 0x34, 0x3c, 0xda, 0xbe, 0xa3, 0x36,
            0xda, 0xe5, 0x40, 0xb7, 0x88, 0x99, 0x56, 0xf1, 0xf1, 0xd8, 0xd4, 0x6b, 0xa2, 0x3e,
            0x5e, 0x44, 0xbf, 0x57, 0x23, 0xae, 0xf2, 0xa8, 0xe6, 0xb6, 0x98, 0x68, 0x6c, 0x02,
            0x58, 0x36, 0x18, 0xa0, 0x00, 0x00, 0x00, 0x00, 0xa1, 0x01, 0x00, 0x00, 0x00, 0xa2,
            0x00, 0xb0, 0x2c, 0xf2, 0x4d, 0xba, 0x5f, 0xb0, 0xa3, 0x0e, 0x26, 0xe8, 0x3b, 0x2a,
            0xc5, 0xb9, 0xe2, 0x9e, 0x1b, 0x16, 0x1e, 0x5c, 0x1f, 0xa7, 0x42, 0x5e, 0x73, 0x04,
            0x33, 0x62, 0x93, 0x8b, 0x98, 0x24, 0xb1, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc,
            0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb,
            0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0xb2, 0x00,
            0x79, 0x22, 0x4e, 0xa5, 0x14, 0x20, 0x67, 0x06, 0x29, 0x8d, 0x8d, 0x62, 0x0f, 0x66,
            0x08, 0x28, 0xf7, 0x98, 0x70, 0x68, 0xd6, 0xd0, 0x27, 0x57, 0xe6, 0xf3, 0xcb, 0xbf,
            0x4a, 0x51, 0xab, 0x13, 0x33, 0x95, 0xdb, 0x69, 0xdb, 0x1b, 0xc9, 0xb2, 0x72, 0x6d,
            0xd9, 0x9e, 0x34, 0xef, 0xc2, 0x52, 0xd8, 0x25, 0x8d, 0xcb, 0x00, 0x3e, 0xba, 0xba,
            0x42, 0xbe, 0x34, 0x9f, 0x50, 0xf7, 0x76, 0x5e, 0xb3, 0x4c, 0xb5, 0xab, 0xf6, 0xad,
            0x79, 0xfb, 0xf5, 0xab, 0xbc, 0xca, 0xfc, 0xc2, 0x69, 0xd8, 0x5c, 0xd2, 0x65, 0x1e,
            0xd4, 0xb8, 0x85, 0xb5, 0x86, 0x9f, 0x24, 0x1a, 0xed, 0xf0, 0xa5, 0xba, 0x29, 0xb4,
            0xce, 0x99, 0x3a, 0xdc, 0x51, 0x11, 0x13, 0x09, 0xa0, 0x41, 0xfa, 0xa6, 0x5c, 0xbc,
            0xf1, 0x15, 0x4d, 0x21, 0xed, 0x0e, 0xcd, 0xc2, 0xd5, 0x40, 0x70, 0xbc, 0x90, 0xb9,
            0xde, 0xb7, 0x44, 0xaa, 0x86, 0x05, 0xb3, 0xf6, 0x86, 0xfa, 0x17, 0x8f, 0xba, 0x21,
            0x07, 0x0b, 0x4a, 0x46, 0x78, 0xe5, 0x4e, 0xee, 0x34, 0x86, 0xa8, 0x81, 0xe0, 0xe3,
            0x28, 0x25, 0x1c, 0xd3, 0x79, 0x66, 0xde, 0x09, 0xb5, 0x00, 0x00, 0x78, 0x62, 0xa4,
            0x41, 0xa7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0xbe, 0xe5, 0x18, 0xac, 0xe9,
            0xdd, 0x1d, 0x50, 0xb6, 0x62, 0x06, 0x59, 0x92, 0x19, 0x4b, 0x9e, 0x2b, 0x1d, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x00, 0x06, 0x53, 0x6f, 0x6d,
            0x65, 0x49, 0x64, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xb7,
            0x02, 0x21, 0x03, 0x1b, 0x84, 0xc5, 0x56, 0x7b, 0x12, 0x64, 0x40, 0x99, 0x5d, 0x3e,
            0xd5, 0xaa, 0xba, 0x05, 0x65, 0xd7, 0x1e, 0x18, 0x34, 0x60, 0x48, 0x19, 0xff, 0x9c,
            0x17, 0xf5, 0xe9, 0xd5, 0xdd, 0x07, 0x8f, 0xb7, 0x03, 0x43, 0x96, 0x8a, 0x72, 0x59,
            0x54, 0x45, 0xda, 0x96, 0x78, 0x86, 0x59, 0xdd, 0x39, 0x9f, 0xaa, 0x20, 0x20, 0x02,
            0x07, 0x07, 0x32, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x07, 0xd2, 0x01, 0x10, 0x02,
            0x00, 0x00, 0x00, 0x30, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x61, 0x73, 0x6d, 0x01,
            0x00, 0x00, 0x00, 0x04, 0x05, 0x01, 0x70, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x00,
            0x10, 0x06, 0x19, 0x03, 0x7f, 0x01, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b, 0x7f, 0x00,
            0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b, 0x7f, 0x00, 0x41, 0x80, 0x80, 0xc0, 0x00, 0x0b,
            0x07, 0x25, 0x03, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x0a, 0x5f,
            0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x65, 0x6e, 0x64, 0x03, 0x01, 0x0b, 0x5f, 0x5f,
            0x68, 0x65, 0x61, 0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x03, 0x02, 0x00, 0x19, 0x04,
            0x6e, 0x61, 0x6d, 0x65, 0x07, 0x12, 0x01, 0x00, 0x0f, 0x5f, 0x5f, 0x73, 0x74, 0x61,
            0x63, 0x6b, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x00, 0x4d, 0x09, 0x70,
            0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x72, 0x73, 0x02, 0x08, 0x6c, 0x61, 0x6e, 0x67,
            0x75, 0x61, 0x67, 0x65, 0x01, 0x04, 0x52, 0x75, 0x73, 0x74, 0x00, 0x0c, 0x70, 0x72,
            0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x2d, 0x62, 0x79, 0x01, 0x05, 0x72, 0x75,
            0x73, 0x74, 0x63, 0x1d, 0x31, 0x2e, 0x35, 0x39, 0x2e, 0x30, 0x20, 0x28, 0x39, 0x64,
            0x31, 0x62, 0x32, 0x31, 0x30, 0x36, 0x65, 0x20, 0x32, 0x30, 0x32, 0x32, 0x2d, 0x30,
            0x32, 0x2d, 0x32, 0x33, 0x29, 0x32, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x22,
            0x00, 0x22, 0x00, 0x01, 0xb2, 0x01, 0xb7, 0xe5, 0x56, 0x2c, 0xf5, 0xec, 0xbb, 0x9b,
            0x7d, 0xbf, 0x19, 0xd7, 0xcd, 0x1c, 0x6c, 0x78, 0x38, 0x18, 0x87, 0x25, 0x7b, 0x0d,
            0x73, 0x8a, 0x34, 0xa4, 0xb3, 0x65, 0xb9, 0x07, 0xa4, 0x67, 0x6a, 0x1b, 0x9c, 0xb1,
            0xfc, 0x10, 0x70, 0xb8, 0x7a, 0xc3, 0x47, 0x43, 0xa0, 0xa9, 0xa9, 0x16, 0x0b, 0xd1,
            0xdf, 0xce, 0xfc, 0xce, 0x84, 0x25, 0xdb, 0xf3, 0xed, 0xa3, 0x4d, 0xad, 0xe2, 0xe4,
        ];
        check_partial_decoding(&input);
    }
}
